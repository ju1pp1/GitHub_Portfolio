stages:
  - build
  - test
  - package
  - smoke
  - deploy

# ---- Global variables ----
variables:
  # Harbor
  REGISTRY: "$HARBOR_URL"
  PROJECT: "$HARBOR_PROJECT2"
  IMAGE_TAG: "$CI_COMMIT_REF_NAME"
  
  APP_DIR: /opt/project1-app
  DATA_DIR: /opt/project1-data

# ---- SSH jobs (for deploy) ----
.default_ssh: &default_ssh
  image: public.ecr.aws/docker/library/alpine:3.20
  before_script:
    - apk add --no-cache openssh-client bash rsync
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" | base64 -d > ~/.ssh/id_ed25519
    - chmod 600 ~/.ssh/id_ed25519
    - |
      cat > ~/.ssh/config <<EOF
      Host vm
        HostName $SSH_HOST
        User $SSH_USER
        Port ${SSH_PORT:-22}
        StrictHostKeyChecking no
        IdentityFile ~/.ssh/id_ed25519
      EOF

# -------------------------------------------------------------------
# 1. BUILD  â€“ compile / basic checks
# -------------------------------------------------------------------
build:
  stage: build
  image: mcr.microsoft.com/dotnet/sdk:8.0-alpine
  rules:
    # run this pipeline for tags like project1.0, project1.1, ...
    - if: '$CI_COMMIT_BRANCH =~ /^project1\./'
  script:
    - |
      echo "Building sources for tag: $CI_COMMIT_TAG"

      cd Assignment3/service2
      dotnet restore
      dotnet build -c Release

      cd ../service1
      apk add --no-cache nodejs npm
      npm ci

      cd ../storage
      python3 -m py_compile app.py || true

  artifacts:
    # Not strictly required, but shows "compiled result" kept between stages
    paths:
      - Assignment3/service2/bin/
      - Assignment3/service2/obj/
    expire_in: 1 day

# -------------------------------------------------------------------
# 2. TEST â€“ simple tests
# -------------------------------------------------------------------
test:
  stage: test
  image: mcr.microsoft.com/dotnet/sdk:8.0-alpine
  rules:
    - if: '$CI_COMMIT_BRANCH =~ /^project1\./'
  needs: ["build"]
  script:
    - |
      echo "Running tests for tag: $CI_COMMIT_TAG"

      # Minimal "tests": verify key files exist and dotnet can run the app
      test -f Assignment3/service1/server.js
      test -f Assignment3/service2/program.cs
      test -f Assignment3/storage/app.py

      cd Assignment3/service2
      dotnet publish -c Release -o /tmp/service2-publish
  after_script:
    - rm -rf /tmp/service2-publish || true

# -------------------------------------------------------------------
# 3. PACKAGE â€“ build Docker images (but do not push yet) 
# -------------------------------------------------------------------
package:
  stage: package
  image: docker:27
  services: [docker:27-dind]
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
  tags: ["docker"]
  rules:
    - if: '$CI_COMMIT_BRANCH =~ /^project1\./'
  needs: ["test"]
  script:
    - IMAGE_TAG="${CI_COMMIT_TAG:-$CI_COMMIT_REF_NAME}"
    - echo "PACKAGE â€“ build & push images for $IMAGE_TAG"
    - docker version
    - echo "$HARBOR_PASSWORD" | docker login "$REGISTRY" -u "$HARBOR_USERNAME" --password-stdin

    # Build once with final registry tags
    - docker build -t "$REGISTRY/$PROJECT/service1:${IMAGE_TAG}" Assignment3/service1
    - docker build -t "$REGISTRY/$PROJECT/service2:${IMAGE_TAG}" Assignment3/service2
    - docker build -t "$REGISTRY/$PROJECT/storage:${IMAGE_TAG}"  Assignment3/storage
    - docker build -t "$REGISTRY/$PROJECT/gateway:${IMAGE_TAG}"  Assignment3/gateway
    - docker build -t "$REGISTRY/$PROJECT/console:${IMAGE_TAG}"  Assignment3/console

    # Push (this replaces the old Deliver stage)
    - docker push "$REGISTRY/$PROJECT/service1:${IMAGE_TAG}"
    - docker push "$REGISTRY/$PROJECT/service2:${IMAGE_TAG}"
    - docker push "$REGISTRY/$PROJECT/storage:${IMAGE_TAG}"
    - docker push "$REGISTRY/$PROJECT/gateway:${IMAGE_TAG}"
    - docker push "$REGISTRY/$PROJECT/console:${IMAGE_TAG}"
  after_script:
    - docker system prune -f || true
    - docker builder prune -f || true

# -------------------------------------------------------------------
# 4. SMOKE â€“ run the stack in CI and verify it starts
# -------------------------------------------------------------------
smoke:
  stage: smoke
  image: docker:27
  services: [docker:27-dind]
  tags: ["docker"]
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
  rules:
    - if: '$CI_COMMIT_BRANCH =~ /^project1\./'
  needs: ["package"]
  script:
    - IMAGE_TAG="${CI_COMMIT_TAG:-$CI_COMMIT_REF_NAME}"
    - echo "SMOKE â€“ pull & run images for $IMAGE_TAG"
    - docker version
    - apk add --no-cache curl
    - echo "$HARBOR_PASSWORD" | docker login "$REGISTRY" -u "$HARBOR_USERNAME" --password-stdin
    - cd Assignment3
    - |
      cat > docker-compose.smoke.yml <<EOF
      services:
        storage:
          image: $REGISTRY/$HARBOR_PROJECT2/storage:${IMAGE_TAG}
          container_name: smoke_storage
        service2:
          image: $REGISTRY/$HARBOR_PROJECT2/service2:${IMAGE_TAG}
          container_name: smoke_service2
          environment:
            - STORAGE_HOST=smoke_storage
            - STORAGE_PORT=8080
          depends_on: [storage]
        service1:
          image: $REGISTRY/$HARBOR_PROJECT2/service1:${IMAGE_TAG}
          container_name: smoke_service1
          environment:
            - STORAGE_URL=http://smoke_storage:8080
            - SERVICE2_URL=http://smoke_service2:9090
          ports:
            - "18000:8199"
          depends_on: [service2, storage]
      EOF
    - docker compose -f docker-compose.smoke.yml up -d
    - sleep 15
    - docker compose -f docker-compose.smoke.yml ps
    - docker run --rm --network assignment3_default curlimages/curl:8.11.1 http://smoke_service1:8199/status
  after_script:
    - docker system prune -af || true
    - docker builder prune -af || true

# -------------------------------------------------------------------
# 5. DEPLOY â€“ pull from Harbor and start on CSC VM
# -------------------------------------------------------------------
deploy:
  stage: deploy
  <<: *default_ssh
  rules:
    - if: '$CI_COMMIT_BRANCH =~ /^project1\./'
  needs: ["smoke"]
  script:
    - IMAGE_TAG="${CI_COMMIT_TAG:-$CI_COMMIT_REF_NAME}"
    - echo "DEPLOY - deploying $IMAGE_TAG to VM"
    - |
      ssh vm <<EOF
      set -euo pipefail
      APP_DIR="$APP_DIR"
      DATA_DIR="$DATA_DIR"
      if ! command -v docker >/dev/null 2>&1; then
        curl -fsSL https://get.docker.com | sh
        sudo usermod -aG docker \$USER || true
      fi
      if ! docker compose version >/dev/null 2>&1; then
        DOCKER_CONFIG=\${DOCKER_CONFIG:-\$HOME/.docker}
        mkdir -p "\$DOCKER_CONFIG/cli-plugins"
        curl -SL https://github.com/docker/compose/releases/download/v2.29.7/docker-compose-linux-x86_64 \
          -o "\$DOCKER_CONFIG/cli-plugins/docker-compose"
        chmod +x "\$DOCKER_CONFIG/cli-plugins/docker-compose"
      fi
      sudo mkdir -p "\$APP_DIR" "\$DATA_DIR"
      sudo chown -R "\$USER:\$USER" "\$APP_DIR" "\$DATA_DIR"

      cat > "\$APP_DIR/docker-compose.yml" <<COMPOSE
      services:
        service1_v1:
          image: $REGISTRY/$PROJECT/service1:project1.0
          container_name: app_v1_service1
          environment:
            - STORAGE_URL=http://project1_storage:8080
            - SERVICE2_URL=http://app_v1_service2:9090
          depends_on:
            - service2_v1
            - storage
        service2_v1:
          image: $REGISTRY/$PROJECT/service2:project1.0
          container_name: app_v1_service2
          environment:
            - STORAGE_HOST=project1_storage
            - STORAGE_PORT=8080
          depends_on:
            - storage
        service1_v2:
          image: $REGISTRY/$PROJECT/service1:project1.1
          container_name: app_v2_service1
          environment:
            - STORAGE_URL=http://project1_storage:8080
            - SERVICE2_URL=http://app_v2_service2:9090
          depends_on:
            - service2_v2
            - storage
        service2_v2:
          image: $REGISTRY/$PROJECT/service2:project1.1
          container_name: app_v2_service2
          environment:
            - STORAGE_HOST=project1_storage
            - STORAGE_PORT=8080
          depends_on:
            - storage
        storage:
          image: $REGISTRY/$PROJECT/storage:project1.0
          container_name: project1_storage
          volumes:
            - /opt/project1-data:/data
        gateway:
          image: $REGISTRY/$PROJECT/gateway:${IMAGE_TAG}
          container_name: project1_gateway
          depends_on:
            - service1_v1
            - service2_v1
            - storage
            - console
          ports:
            - "8196:8198"
            - "8197:8199"
          volumes:
            - /etc/letsencrypt/live/gateway.jerand25.treok.eu/fullchain.pem:/etc/nginx/certs/fullchain.pem:ro
            - /etc/letsencrypt/live/gateway.jerand25.treok.eu/privkey.pem:/etc/nginx/certs/privkey.pem:ro
        console:
          image: $REGISTRY/$PROJECT/console:${IMAGE_TAG}
          container_name: project1_console
          depends_on:
            - storage
          volumes:
            - /var/run/docker.sock:/var/run/docker.sock
      COMPOSE

      echo "$HARBOR_PASSWORD" | docker login "$REGISTRY" -u "$HARBOR_USERNAME" --password-stdin

      # ðŸ”‘ NEW: stop/remove any existing stack first
      docker compose -f "\$APP_DIR/docker-compose.yml" down --remove-orphans || true

      # then pull + start fresh
      docker compose -f "\$APP_DIR/docker-compose.yml" pull
      docker compose -f "\$APP_DIR/docker-compose.yml" up -d
      docker compose -f "\$APP_DIR/docker-compose.yml" ps
      EOF
  after_script:
    - ssh vm "docker image prune -af || true"
    - ssh vm "docker builder prune -af || true"